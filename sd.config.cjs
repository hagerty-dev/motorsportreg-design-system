const StyleDictionary = require('style-dictionary');
const { Parser } = require('expr-eval');
const { parseToRgba } = require('color2k');
const fs = require('fs');
const parser = new Parser();

// HEHE, OK this got way larger than I thought.
// TODO: Split into seperate chunks next round. See where this goes.

/** HELPER FUNCTIONS
 * ------------------------------------------------------------------------- */
function checkAndEvaluateMath(expr) {
  try {
    parser.evaluate(expr);
    return +parser.evaluate(expr).toFixed(3);
  } catch (ex) {
    return expr;
  }
}

function transformDimensionToPx(value) {
  if (value.endsWith('px')) {
    return value;
  }
  return value + 'px';
}

function transformLetterSpacingToEm(value) {
  if (value.endsWith('%')) {
    const percentValue = value.slice(0, -1);
    return `${percentValue / 100}em`;
  }
  return value;
}

function transformHEXToRGBa(value) {
  if (value.startsWith('rgba(#')) {
    const [hex, alpha] = value.replace(')', '').split('rgba(').pop().split(',');
    const [r, g, b] = parseToRgba(hex);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  } else {
    return value;
  }
}

/**
 * Transforms boxShadow object to shadow shorthand
 * This currently works fine if every value uses an alias, but if any one of these use a raw value, it will not be transformed.
 */
function transformShadow(shadow) {
  const { x, y, blur, spread, color } = shadow;
  return `${x}px ${y}px ${blur}px ${spread}px ${color}`;
}

/** TRANSFORMERS
 * ------------------------------------------------------------------------- */

/**
 * Shadow shorthand
 */
StyleDictionary.registerTransform({
  name: 'shadow/shorthand',
  type: 'value',
  transitive: true,
  matcher: (token) => ['boxShadow'].includes(token.type),
  transformer: (token) => {
    return Array.isArray(token.original.value)
      ? token.original.value.map((single) => transformShadow(single)).join(', ')
      : transformShadow(token.original.value);
  },
});
/**
 * Hex in Rgb to RgbA with correct values
 */
StyleDictionary.registerTransform({
  name: 'color/hexrgba',
  type: 'value',
  transitive: true,
  matcher: (token) =>
    typeof token.value === 'string' && token.value.startsWith('rgba(#'),
  transformer: (token) => transformHEXToRGBa(token.value),
});

/**
 * Add px to font sizes
 */
StyleDictionary.registerTransform({
  name: 'size/px',
  type: 'value',
  transitive: true,
  matcher: (token) =>
    ['fontSizes', 'dimension', 'borderRadius', 'spacing'].includes(token.type),
  transformer: (token) => transformDimensionToPx(token.value),
});

/**
 * Transform letterSpacing to em
 */
StyleDictionary.registerTransform({
  name: 'size/letterspacing',
  type: 'value',
  transitive: true,
  matcher: (token) => token.type === 'letterSpacing',
  transformer: (token) => transformLetterSpacingToEm(token.value),
});

/**
 * Calc or resolve math in tokens
 */
StyleDictionary.registerTransform({
  name: 'resolveMath',
  type: 'value',
  transitive: true,
  matcher: (token) => token,
  transformer: (token) => `${checkAndEvaluateMath(token.value)}`,
});

/**
 * Where token have math and strings, calculate and add px
 */
StyleDictionary.registerTransform({
  name: 'computeFontSizeStringToNumber',
  type: 'value',
  transitive: true,
  matcher: (token) =>
    typeof token.value === 'string' && token.value.includes('*'),
  transformer: (token) => {
    const parts = token.value.split('*').map((str) => parseFloat(str.trim()));
    const sum = parts.reduce((total, value) => {
      return total * value;
    }, 1);
    return sum + 'px';
  },
});

// /**
//  * Format for css variables
//  */
// StyleDictionary.registerFormat({
//   name: 'css/variables',
//   formatter: function (dictionary, config) {
//     return `${this.selector} {
// ${dictionary.allProperties
//   .map((prop) => `  --${prop.name}: ${prop.value};`)
//   .join('\n')}
// }`;
//   },
// });

/** SETTINGS
 * ------------------------------------------------------------------------- */

module.exports = {
  source: ['sd-input/figma/core.json'], // TODO: Update to export component Tokens to folders
  fileHeader: {
    autoGeneratedFileHeader: () => {
      return [
        `MSR Designtokens. Do not edit directly, this file was auto-generated`,
      ];
    },
  },
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'tokens/',
      prefix: 'msr',
      transforms: [
        'resolveMath',
        'computeFontSizeStringToNumber',
        'shadow/shorthand',
        'name/cti/kebab',
        'color/hexrgba',
      ],
      files: [
        {
          destination: 'variables.css',
          format: 'css/variables',
          options: {
            fileHeader: 'autoGeneratedFileHeader',
          },
        },
      ],
    },
    // scss: {
    //   transformGroup: 'scss',
    //   buildPath: 'tokens/',
    //   prefix: 'msr',
    //   files: [
    //     {
    //       destination: '_variables.scss',
    //       format: 'scss/variables',
    //       options: {
    //         fileHeader: 'autoGeneratedFileHeader',
    //       },
    //     },
    //   ],
    // },
  },
};
